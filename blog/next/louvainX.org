#+OPTIONS: toc:nil num:nil todo:nil pri:nil tags:nil ^:nil TeX:nil
#+CATEGORY: MOOC
#+TAGS: edX
#+DESCRIPTION:
#+TITLE: Paradigms of Computer Programming

* はじめに

** プログラミングパラダイムとは
プログラミングパラダイムとは、プログラミングの分類方法、スコープ、見方。

なにかを定義しているようでなにもいっていない・・・すみません、詳しくはwikipedia参照ということで。

- [[http://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%91%E3%83%A9%E3%83%80%E3%82%A4%E3%83%A0][プログラミングパラダイム - Wikipedia]]

** パラダイムを学ぶ動機・意義
講座のなかでは、以下のような利点を強調してモチベーションをあげようとしている。

- いくつものプログラミング言語がある。全てを学ぶことは不可能。
- プログラミング言語はパラダイムで分類できる。
- パラダイム、そこから導出れるコンセプトを抑えることで、多くの言語を理解できる！

なるほど、利にかなっている。

今は、仕事だとオブジェクト指向が全盛だが、その天下もいつまで続くかは分からない。

技術が進めばマルチコアや並列処理に対応するために、それに適した言語が必要になるかもしれない。
HTMLなんかは宣言的プログラミングの典型で、オブジェクト指向ではどうにもならない。

プロフェッショナルなプログラマを目指すのならば、
オブジェクト指向だけでなくて、他の考え方も知っておきたいところだ。

* 各種プログラムパラダイムの簡潔なまとめ
講義で説明された概念について、簡単にメモしていきます。

** Paradigm(パラダイム)
*** functional programming(関数型プログラミング)
*** Obbject-oriented programming(オブジェクト思考型プログラミング)
*** Detarministic dataflow programming(決定性データフロープログラミング)
*** Multi-agent dataflow programmming


** Concept(コンセプト)
**** Identifiers and environments(識別子と環境)
x = 1 ということはどういうことかを説明する概念。

数学的な写像関係で x = 1 を説明しようとしている。{ X -> x1=1 }みたいな感じ。
x1がメモリ上の実際の(束縛された)値で、Xがそれを指し示す識別子。

その写像関係を環境という。

**** functional programming

**** Recursion
再帰的プログラミング。

***** accumulater
C++の、numericライブラリ(accumuulateなど)で利用されている。

スタックのサイズが均一なことが特徴的。

***** tail-recursion(末尾再帰）
その中にただ1つの再帰呼び出しがあり、
かつその呼び出しが手続き本体の最後にあるもの。

#+begin_src C++
state whileLoop(state s) {
  while (!isDone(s)) // 終了条件
    s = transform(s) // 再帰
  return s;
}

#+end_src

***** invariant programming(不変式プログラミング)
再帰的に呼ばれる度に、数学的に真になる式。

- [[http://ja.wikipedia.org/wiki/%E4%B8%8D%E5%A4%89%E6%9D%A1%E4%BB%B6][不変条件 - Wikipedia]]

*** List, trees, and records
*** Symbolic programming
*** Instantiation
*** Genericity
*** Higher-order programming(高階プログラミング)
procedure valueをサポートしている言語でのプログラミング技術。
関数を引数としてわたす能力。

Rubyではlambda, procなど。C言語には関数ポインタがある。C言語は2階。

*** Kernel languages
*** Abstract machines
*** Mathematial semantics
*** Explicit state
*** Data abstraction
*** Polymorphism
*** Inheritance
*** Object-oriented programming
*** Exception handling
*** Dataflow synchronizaton
*** Deterministic concurrency
*** Nondeterminism
*** Multiagent programming
