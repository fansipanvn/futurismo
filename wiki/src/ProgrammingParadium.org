#+OPTIONS: toc:nil
* プログラミングパラダイム

- [[http://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%91%E3%83%A9%E3%83%80%E3%82%A4%E3%83%A0][プログラミングパラダイム - Wikipedia]]

* 基本コンセプト
** Valiables
変数の構成要素は以下の2つ。

- 識別子(Identifier)
- 格納域実体(Store entity)

*** Identifires and Store Entity
x = 1 ということはどういうことかを説明する概念。

数学的な写像関係で x = 1 を説明しようとしている。{ X -> x1=1 }みたいな感じ。
x1がメモリ上の実際の(束縛された)値で、Xがそれを指し示す識別子。

*** environments
識別子と変数の写像関係を環境という。

*** Scope
Valiableの有効範囲。

** State
State(状態）とは、必要とされる計算の途中結果を含む、値の時系列。
(sequence of values calculated progressively,
which contains the intermediate results of a computation)

状態の導入によって、プログラムに時間の概念を与える。

** Operational Semantics
wikipedia: [[http://ja.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%9A%84%E6%84%8F%E5%91%B3%E8%AB%96][操作的意味論 - Wikipedia]]
    
プログラムの正しさを数学的に証明することを目指す。

- Specification ・・・ プログラムの入力と出力を定義したものを
- Program ・・・ プログラミング言語によってかかれたデータ

ProgramがSpecificationを満たしているかを証明する。そのために、

- Semantic(意味の対応付け）
- Abstruct Machine(抽象化された実行環境）

という概念を導入する。Programはkernel Languageに分解され、Kernel Language
の構成要素がAbstruct Machineと対応付けられる。

#+begin_src language
                             Semanitic 
    Program --> kernel Language ----->  Specification
                            Abstrucut Machine
#+end_src

プログラミングが正しいことは、数学的帰納法(mathematical induction)で証明する。

*** example
**** Specification
      
#+begin_src language
0! = 1
n! = n×(n-1)!  when n>0
#+end_src

**** Program

#+begin_src oz
fun {Fact N}
   if N==0 then 1 else N*{Fact N-1} end
end
#+end_src

**** Semanitc Expression

#+begin_src language
E={Fact→fact, N→n, R→r} (AbstcutMachine)
σ={fact=(proc ... end,CE),n=0,r} (memory)
CE={Fact→fact}. ( Contectual Environment)

{Fact N R}, E, σ
#+end_src

** Exceptions
例外。プログラムがある処理を実行している途中で、
なんらかの異常が発生した場合に、
現在の処理を中断（中止）して、別の処理を行うこと。
その際に発生した異常のことを例外と呼ぶ

- [[http://ja.wikipedia.org/wiki/%E4%BE%8B%E5%A4%96%E5%87%A6%E7%90%86][例外処理 - Wikipedia]]

よくある2つの概念。

- try  ・・・ 例外ハンドラをもつ例外補足コンテクストを生成。  
- raise・・・ もっとも内部の例外補足コンテキストへjampし、そこにある例外ハンドラを起動。

各コンテキストはスタックで管理され、tryはスタックの１つにmarkerをつける。
raiseはmarkerにジャンプしてmarkerの場所に例外処理のコンテキストを挿入する。

CTM p93参照。

例外をつかわないと、コンテクストごとの結果を検証必要があり、
case文が乱立するうんこコードが出来る。

* Functional programming
関数型プログラミング。

- [[http://ja.wikipedia.org/wiki/%E9%96%A2%E6%95%B0%E5%9E%8B%E8%A8%80%E8%AA%9E][関数型言語 - Wikipedia]]

すべての計算や処理などを関数の定義の組み合わせとして記述していくタイプのプログラミング言語。

「同じ入力には必ず同じ出力を返す」「関数の評価が他の関数に影響を及ぼさない」など
数学における関数と似た性質を持った関数の定義としてプログラミングを行い、
プログラムの実行は記述された関数群の評価として行われる。

- [[http://e-words.jp/w/E996A2E695B0E59E8BE8A880E8AA9E.html][関数型言語とは 【 functional language 】： IT用語辞典]]

広義の意味では、Whatをコンピュータに示すもの（Howを示さない）。
狭義の意味では、プログラミングの中で数学を用いたもの(Function, Relation)。

- 式と関数でプログラムを組み上げる(Use of MathMatics)
- 関数を値として扱える(Higher-order programming)
- 副作用を起こさない(Impliclite State, Stateless)

- ttp://itpro.nikkeibp.co.jp/article/COLUMN/20110411/359286/?ST=develop&P=3][3つのプログラミングのパラダイムを押さえておこう：ITpro]]

** Impliclite(declarative) State
暗黙的状態。宣言的状態ともいう。

- 関数の実行結果が値をもつ
- 同じ入力には必ず同じ出力を返す。
- Explicite Stateとの対概念。
- 参照透明性。

** Higher-order programming
高階プログラミング。procedure valueをサポートしている言語でのプログラミング技術。
関数を引数としてわたす能力。

Rubyではlambda, procなど。C言語には関数ポインタがある。C言語は2階。

** Recursion
再帰的プログラミング。

*** accumulater
C++の、numericライブラリ(accumuulateなど)で利用されている。

スタックのサイズが均一なことが特徴的。

*** tail-recursion
末尾再帰。

その中にただ1つの再帰呼び出しがあり、
かつその呼び出しが手続き本体の最後にあるもの。

#+begin_src C++
state whileLoop(state s) {
  while (!isDone(s)) // 終了条件
    s = transform(s) // 再帰
  return s;
}
#+end_src

*** invariant programming
不変式プログラミング。再帰的に呼ばれる度に、数学的に真になる式。

- [[http://ja.wikipedia.org/wiki/%E4%B8%8D%E5%A4%89%E6%9D%A1%E4%BB%B6][不変条件 - Wikipedia]]

* Declarative Programming
宣言型プログラミング。

第1の意味は、
処理方法ではなく対象の性質などを宣言することでプログラミングするパラダイム。
第2の意味は、
純粋関数型プログラミング、論理プログラミング、制約プログラミングの総称。

- [[http://ja.wikipedia.org/wiki/%E5%AE%A3%E8%A8%80%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0][宣言型プログラミング - Wikipedia]]

- Imperative Programingの対になる概念。
  "Function without State"

- Imperative vs Declaretive is also Stateful vs Stateless
  
HTMLはStateless、Declarative Programming language.
状態はクッキーを導入してしばしば実現する。

** 主な言語
- HTML
- MySQL
  
* Imperative Programming
命令型プログラミング。
計算をプログラム状態を変化させる文の列で記述するパラダイム。

- [[http://ja.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0][命令型プログラミング - Wikipedia]]

Imperative programmingとは、Function paradigmにCellの概念を加えたもの。

- Declarative Programingの対になる概念。
  Imperative vs Declaretive is also Stateful vs Stateless

#+begin_src language
Imperative programming = Function paradigm + Cell
#+end_src

- 実行するたびに、内部の状態によって結果がことなる。

- 手続き型と同義のこともある。
手順やチェックリストはプログラムではないが、
命令型プログラミングのスタイルに似たコンセプトである。
それらのステップが命令であり、実世界が状態を保持している。

- 械語は命令から構成される
低レベルから見た場合、
プログラムの状態はメモリの内容によって定義され、文としては機械語の命令が相当する。

** Explicite State
明示的状態。

- 生存期間が2度以上の手続的呼び出しに渡るような一つの状態。
- 関数の実行の中に値をもつ。
- 手続きの引数に現れないもの。

同様なことを関数型パラダイムで実現するためには、仮引数に状態を持たないといけない。

** Cell
Explicite State(明示的状態)を表す基本型。二つの構成要素からなる。

- 名前値(Vaiue)
- 単一代入格納域への参照(Identifier)

#+begin_src oz
declare
fun {Reverse L}
   % 空リストのcellを生成
   Rs = {NewCell nil}
in
   % リストの各要素を取り出して内部Cellに結合
   for X in L do
      Rs := X|@Rs
   end

   % 内部セルをリターンする。
   % Rubyっぽい！
   @Rs
end

{Show {Reverse [1 2 3 4]}}
#+end_src

Function ParadigmsとImperative Paradigmの違いは、

- Function 
  - 状態変化しない(Immunity)
  - 機能追加時にインタフェースの変更の影響度がおおきい。
- Inperative
  - 機能追加時にインタフェースの変更の影響度がない。(モジュール性, モジュールプログラミング）
  - 状態変化する。

** 主な言語
- C言語

* Structured programming
構造化プログラミング。

構造化プログラミングではプログラミング言語が持つステートメントを
直接使ってプログラムを記述するのではなく、
それらを抽象化したステートメントを持つ仮想機械を想定し、
その仮想機械上でプログラムを記述する。
普通、抽象化は1段階ではなく階層的である。
各階層での実装の詳細は他の階層と隔離されており、
実装の変更の影響はその階層内のみに留まる(Abstract data structures)。
各階層はアプリケーションに近い抽象的な方から土台に向かって順序付けられている。
pこの順序は各階層を設計した時間的な順番とは必ずしも一致しない(Concluding remarks)

[[http://ja.wikipedia.org/wiki/%E6%A7%8B%E9%80%A0%E5%8C%96%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0][- 構造化プログラミング - Wikipedia]]

標準的な制御構造のみを使い、
プログラム全体を段階的に細かな単位に分割して処理を記述していく手法。

- [[http://e-words.jp/w/E6A78BE980A0E58C96E38397E383ADE382B0E383A9E3839FE383B3E382B0.html][構造化プログラミングとは 【 structured programming 】 ： IT用語辞典]]

「制御の流れ」を構造化しただけであり、
「データ構造」には何の制限や規則も設けていない。

「芸術品」から脱却して「工業製品」へ遷移すること、
あるいは、「処理性能重視」から「保守性重視」へ向かったもの。
別の見方をすれば、処理効率を犠牲にして、作りやすさや理解容易性を求めたもの。

- [[http://monoist.atmarkit.co.jp/mn/articles/1009/17/news118.html][構造化プログラミングからオブジェクト指向への進化 - MONOist（モノイスト）]]

** 三つの構造化文
ダイクストラが提唱。

- 順次
順接、順構造とも言われる。
プログラムに記された順に、逐次処理を行なっていく。
プログラムの記述とコンピュータの動作経過が一致するプログラム構造である。

- 反復
一定の条件が満たされている間処理を繰り返す。

- 分岐
ある条件が成立するなら処理Aを、そうでなければ処理Bを行なう。

* Object-Oriented Programming
オブジェクト指向型プログラミング。

- [[http://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0][オブジェクト指向プログラミング - Wikipedia]]

** Data abstraction
データ抽象。3つの構成要素がある。

- Input
- Output
- Interface

データ抽象は内部と外部からなるプログラムかつ、両者がインターフェースを通じてやりとりするもの。

A data abstraction is a part of a program that has an inside, an outside,
and an interface in between The inside is hidden from the outside.

*** Input/Output
内部は外部からは隠蔽されている。-> カプセル化という。

The inside is hidden from the outside

*** Interface
The interface is a set of operations that an be used according to certain rules.

データ抽象には、主に二つの方法がある。

- Abstract Data Type(ADT) keeps values and operations separate.
- Object groups together value and operations in a single entity.

*** Encapsulation
プログラムと内部と内部をインタフェースで分けること。

カプセル化のメリットは大規模開発をシンプルにする。

- 正しさを保証する。
- 複雑さを解消する。
  
*** Abstract Data Type
抽象データ型。ADTと略されることも。

構造化プログラミングは仮想機械モデルに基づく段階的詳細化法（stepwise refinement）をもたらしたが、
データ構造の変更を行うと変更部分がソースコード中に散在してしまうという弱点があった。
データ抽象の概念はその欠点を補完するものであった

- [[http://ja.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B][抽象データ型 - Wikipedia]]

An ADT consists of a set of values and  a set of operations.

- Integer型
 - Value:1,2,3
 - Operation:+
- Stack型
 - Value: elemtent
 - Operation: push, pop, ...

ValueとOperationそれ自体はStateを持たない。

CTM, p433

Diference between ADT and Object。Stackをつかった実装の違い。

- ADT

#+begin_src oz
local Wrap Unwrap in
  {NewWrapper Wrap Unwrap}
  fun {NewStack} {Wrap nil} end
  fun {Push W X} {Wrap X|{Unwrap W}} end
  fun {Pop W X} S={Unwrap W} in X=S.1 {Wrap S.2} end
  fun {IsEmpty W} {Unwrap W}==nil end
end
#+end_src

この手法はStateful ADTという。

そして、C言語では、こうやってデータ抽象化を行うことがおおい。
もちろん関数ポインタ配列を使えばC言語でもObjectをつくることができるが、
実際にはそこまでやらない。(面倒)

- Object
オブジェクトでは、データに対する操作はプロシージャ変数として扱われることに注目。

#+begin_src oz
fun {NewStack}
  C={NewCell nil}
  proc {Push X} C:=X|@C end
  proc {Pop X} S=@C in X=S.1 C:=S.2 end
  fun {IsEmpty} @C==nil end
in
  stack(push:Push pop:Pop isEmpty:IsEmpty)
end
#+end_src

オブジェクト指向言語は、
単にObjectをサポートする言語ではなくて、Abstruct Data Typeも強力にサポートしている。

ObjectとADTの意味がごっちゃにつかわれているのが現実の現状。

** Object
値と操作をひとつのまとまりとしたもの。以下の構成要素をもつ。

- 値 ・・・Explicite State(明示的状態)
- 操作 ・・・Procedural Data Abstruction(手続的データ抽象)

以下の能力を備えている。

*** Data Abstruction
オブジェクトは内部と外部はインタフェースを通じてやりとりされる。

内部の明示的状態をAttributes,インタフェースをMethodsという。

*** Procedure Dispatch
オブジェクトは単一なエントリポイントをもつ。(エントリポイント = 呼び出し口)
エントリポイントに渡される引数をメッセージという。

下の例だと、Counterがエントリポイント。エントリポイントにinc,getメッセージを送る。

#+begin_src oz
   {Counter inc}
   {Counter get(X)}
#+end_src

エントリポイントから、メッセージに対応するプロシージャが呼びだされる。

メッセージとプロシシージャはあらかじめDispatch(バンドリング)されている。

*** Instantiation
オブジェクトは一つのメソッドで、
異なる属性をもつ複数のオブジェクトを生成できる。

この能力をInstantiation(インスタンス化）という。

*** Classes
メソッドと属性を定義する特別なシンタックスをClassという。

属性とメソッドはレコードデータ構造によって管理されているだけである！

Classという概念によって、オブジェクトの"宣言"と"生成(new)"を分離する。

** Polymorphism

   [[http://ja.wikipedia.org/wiki/%E3%83%9D%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%95%E3%82%A3%E3%82%BA%E3%83%A0][- ポリモーフィズム - Wikipedia]]

** Inheritance
継承。あるオブジェクトが他のオブジェクトの特性を引き継ぐこと。

   - [[http://ja.wikipedia.org/wiki/%E7%B6%99%E6%89%BF_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)][継承 (プログラミング) - Wikipedia]]

*** Composition
コンポジション。新たなクラスに、既存クラスのインスタンスを保持する。
has-a の関係(not is-a)

Prefer Composition over inheritance(Effective Java).

*** Delegation
移譲。
   
* Concurrenct Programming
複数の相互作用を及ぼす計算タスクの（同時）並行的実行をおこなうパラダイム。

平行プログラミング。(並列プログラミングではない)。

- [[http://ja.wikipedia.org/wiki/%E4%B8%A6%E8%A1%8C%E8%A8%88%E7%AE%97][並行計算 - Wikipedia]]
- [[http://ja.wikipedia.org/wiki/%E4%B8%A6%E5%88%97%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0][並列計算 - Wikipedia]]

Multiple progressing activities that exist at the same time
Activities that can communicate and synchronize

- Communicate: information passes from one activity to another
- Synchronize: an activity waits for another to perform a specific action

平行プログラミングには3つの代表的なパラダイムがある。

- Detarministic Dataflow
- Message-passing concurrency(Erlang and Scala actor)
- Shared-State concurrency(Java monitors)

* Detarministic Dataflow Programming
決定性データフロープログラミング。

関数型パラダイムをべースにしている。

- [[http://ja.wikipedia.org/wiki/%E3%83%87%E3%83%BC%E3%82%BF%E3%83%95%E3%83%AD%E3%83%BC%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0][データフロープログラミング - Wikipedia]]

スレッド処理、時間経過をともなうのにも関わらず、実行結果はつねに一定！

これが、Deterministicと名づけられた所以。

Deerministic is not Obsarbable.

応用が期待される分野は

- MultiCore, ManyCore Processing (マルチコア、メニーコア)
- Destributed Computing
- Concurrent Deployment

メニーコアやクラウドなどのキーワードと相性のよい、21世紀のパラダイム。

** Detarministic Dataflow
*** Unbound Value
メモリ上に値が存在しないが、宣言された変数。

- C/C++では、ゴミ(不定データ)が格納されている。
- Javaは0初期化されている。
- Prologは実行時にエラー終了する。
- Ozは値がbindされるまでまちあわせる。

*** DataFlow Value
Unbound Valueがbindされるまでプログラムの実行を待ち合わせるような宣言的変数。

Bindされたときの実行を Dataflow Executionという。

** Threads
プログラムの処理の単位(Thread of Program)

- Each thread is sequential.
- Each thread is independent of the others.
- Two threads can communicate if they share a variable

WikipediaではCPUのひとつの処理単位と定義されている。

[[http://ja.wikipedia.org/wiki/%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89_(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF)][- スレッド (コンピュータ) - Wikipedia]]

** Streams
リストの終端がUnbound Variableであるもの。

Streamsは2つのThread間の通信チャネルとして利用できる。

Streamの構成要素は以下。

- Producer
  ストリームのデータを生成。

- Consumer
  Producerから生成されたストリームのデータを受け取ってアクションを起こす。

- Transformer
  ProducerとConsumerとの間を仲介する。  

- Pipeline
  ProducerとConsumerとTransformerの間を仲介する。  

単一格納変数(single-assined value)の性質（一度しか代入できない)
を同期のスレッド間通信のための手段にする。

平行スレッドのなかでStreamを読み書きするものをAgentsという。

n#+begin_src language
          S1=1|2|3..              S2=1|4|9..
  Produce ----------> Transformer --------> Consuemer
 S1={Prod 1}          S2={Trans S1}         {Disp S2}
#+end_src

** NonDeterminism
非決定性。プログラムの実行結果を決定ことができるシステムの能力。

Nondeterminismはmanagedされることが必須！
しかし、制御がとても難しい。
だからこそ、Determinismが重要なのだと。


*** Scheduler
どのスレッドを実行するかを決める、システムの一部をスケジューラという。

* Multi-agent dataflow programmming
マルチエジェーントデータフロープログラミング。

Concurrent Deploymentが応用分野。Immunity Infra。

* Books
* Links
- [[http://www.ibm.com/developerworks/jp/opensource/library/itm-progevo1/][プログラミング言語の進化を追え: 第1回 サルでも分かるプログラミング言語の新潮流(前篇)]]
- [[http://www.ibm.com/developerworks/jp/opensource/library/itm-progevo2/index.html][プログラミング言語の進化を追え: 第2回 サルでも分かるプログラミング言語の新潮流(後篇)]]

