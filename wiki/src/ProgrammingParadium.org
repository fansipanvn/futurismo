#+OPTIONS: toc:nil
* プログラミングパラダイム

- [[http://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%91%E3%83%A9%E3%83%80%E3%82%A4%E3%83%A0][プログラミングパラダイム - Wikipedia]]

* 基本コンセプト
** Identifiers and environments
識別子と環境。

x = 1 ということはどういうことかを説明する概念。

数学的な写像関係で x = 1 を説明しようとしている。{ X -> x1=1 }みたいな感じ。
x1がメモリ上の実際の(束縛された)値で、Xがそれを指し示す識別子。

その写像関係を環境という。

** Scope
Valiableの有効範囲。

** State
State(状態）とは、必要とされる計算の途中結果を含む、値の時系列。
(sequence of values calculated progressively,
which contains the intermediate results of a computation)

状態の導入によって、プログラムに時間の概念を与える。

** Operational Semantics
wikipedia: [[http://ja.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%9A%84%E6%84%8F%E5%91%B3%E8%AB%96][操作的意味論 - Wikipedia]]
    
プログラムの正しさを数学的に証明することを目指す。

- Specification ・・・ プログラムの入力と出力を定義したものを
- Program ・・・ プログラミング言語によってかかれたデータ

ProgramがSpecificationを満たしているかを証明する。そのために、

- Semantic(意味の対応付け）
- Abstruct Machine(抽象化された実行環境）

という概念を導入する。Programはkernel Languageに分解され、Kernel Language
の構成要素がAbstruct Machineと対応付けられる。

#+begin_src language
                             Semanitic 
    Program --> kernel Language ----->  Specification
                            Abstrucut Machine
#+end_src

プログラミングが正しいことは、数学的帰納法(mathematical induction)で証明する。

*** example
**** Specification
      
#+begin_src language
0! = 1
n! = n×(n-1)!  when n>0
#+end_src

**** Program

#+begin_src oz
fun {Fact N}
   if N==0 then 1 else N*{Fact N-1} end
end
#+end_src

**** Semanitc Expression

#+begin_src language
E={Fact→fact, N→n, R→r} (AbstcutMachine)
σ={fact=(proc ... end,CE),n=0,r} (memory)
CE={Fact→fact}. ( Contectual Environment)

{Fact N R}, E, σ
#+end_src


* Functional programming
関数型プログラミング。

- [[http://ja.wikipedia.org/wiki/%E9%96%A2%E6%95%B0%E5%9E%8B%E8%A8%80%E8%AA%9E][関数型言語 - Wikipedia]]

すべての計算や処理などを関数の定義の組み合わせとして記述していくタイプのプログラミング言語。

「同じ入力には必ず同じ出力を返す」「関数の評価が他の関数に影響を及ぼさない」など
数学における関数と似た性質を持った関数の定義としてプログラミングを行い、
プログラムの実行は記述された関数群の評価として行われる。

- [[http://e-words.jp/w/E996A2E695B0E59E8BE8A880E8AA9E.html][関数型言語とは 【 functional language 】： IT用語辞典]]

- 広義の意味では、Whatをコンピュータに示すもの（Howを示さない）。
- 狭義の意味では、プログラミングの中で数学を用いたもの(Function, Relation)。

** Impliclite(declarative) State
暗黙的状態。宣言的状態ともいう。

- 関数の実行結果が値をもつ
- Explicite Stateとの対概念。
- 関数型プログラミングの特徴。

** Recursion
再帰的プログラミング。

*** accumulater
C++の、numericライブラリ(accumuulateなど)で利用されている。

スタックのサイズが均一なことが特徴的。

*** tail-recursion(末尾再帰）
その中にただ1つの再帰呼び出しがあり、
かつその呼び出しが手続き本体の最後にあるもの。

#+begin_src C++
state whileLoop(state s) {
  while (!isDone(s)) // 終了条件
    s = transform(s) // 再帰
  return s;
}
#+end_src

*** invariant programming(不変式プログラミング)
再帰的に呼ばれる度に、数学的に真になる式。

- [[http://ja.wikipedia.org/wiki/%E4%B8%8D%E5%A4%89%E6%9D%A1%E4%BB%B6][不変条件 - Wikipedia]]

*** Higher-order programming
高階プログラミング。procedure valueをサポートしている言語でのプログラミング技術。
関数を引数としてわたす能力。

Rubyではlambda, procなど。C言語には関数ポインタがある。C言語は2階。

* Declarative Programming
宣言型プログラミング。

第1の意味は、
処理方法ではなく対象の性質などを宣言することでプログラミングするパラダイム。
第2の意味は、
純粋関数型プログラミング、論理プログラミング、制約プログラミングの総称。

- [[http://ja.wikipedia.org/wiki/%E5%AE%A3%E8%A8%80%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0][宣言型プログラミング - Wikipedia]]

- Imperative Programingの対になる概念。
  "Function without State"

- Imperative vs Declaretive is also Stateful vs Stateless
  
HTMLはStateless、Declarative Programming language.
状態はクッキーを導入してしばしば実現する。

** 主な言語
- HTML
- MySQL
  
* Imperative Programming
命令型プログラミング。
計算をプログラム状態を変化させる文の列で記述するパラダイム。

- [[http://ja.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0][命令型プログラミング - Wikipedia]]

Imperative programmingとは、Function paradigmにCellの概念を加えたもの。

- Declarative Programingの対になる概念。
  Imperative vs Declaretive is also Stateful vs Stateless

#+begin_src language
Imperative programming = Function paradigm + Cell
#+end_src

- 実行するたびに、内部の状態によって結果がことなる。

- 手続き型と同義のこともある。
手順やチェックリストはプログラムではないが、
命令型プログラミングのスタイルに似たコンセプトである。
それらのステップが命令であり、実世界が状態を保持している。

- 械語は命令から構成される
低レベルから見た場合、
プログラムの状態はメモリの内容によって定義され、文としては機械語の命令が相当する。

** Explicite State
明示的状態。

- 生存期間が2度以上の手続的呼び出しに渡るような一つの状態。
- 関数の実行の中に値をもつ。
- 手続きの引数に現れないもの。

同様なことを関数型パラダイムで実現するためには、仮引数に状態を持たないといけない。

** Cell
Explicite State(明示的状態)を表す基本型。二つの構成要素からなる。

- 名前値(Vaiue)
- 単一代入格納域への参照(Identifier)

#+begin_src oz
declare
fun {Reverse L}
   % 空リストのcellを生成
   Rs = {NewCell nil}
in
   % リストの各要素を取り出して内部Cellに結合
   for X in L do
      Rs := X|@Rs
   end

   % 内部セルをリターンする。
   % Rubyっぽい！
   @Rs
end

{Show {Reverse [1 2 3 4]}}
#+end_src

Function ParadigmsとImperative Paradigmの違いは、

- Function 
  - 状態変化しない(Immunity)
  - 機能追加時にインタフェースの変更の影響度がおおきい。
- Inperative
  - 機能追加時にインタフェースの変更の影響度がない。(モジュール性）
  - 状態変化する。

** 主な言語
- C言語

* Structured programming
構造化プログラミング。

構造化プログラミングではプログラミング言語が持つステートメントを
直接使ってプログラムを記述するのではなく、
それらを抽象化したステートメントを持つ仮想機械を想定し、
その仮想機械上でプログラムを記述する。
普通、抽象化は1段階ではなく階層的である。
各階層での実装の詳細は他の階層と隔離されており、
実装の変更の影響はその階層内のみに留まる(Abstract data structures)。
各階層はアプリケーションに近い抽象的な方から土台に向かって順序付けられている。
この順序は各階層を設計した時間的な順番とは必ずしも一致しない(Concluding remarks)

[[http://ja.wikipedia.org/wiki/%E6%A7%8B%E9%80%A0%E5%8C%96%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0][- 構造化プログラミング - Wikipedia]]

標準的な制御構造のみを使い、
プログラム全体を段階的に細かな単位に分割して処理を記述していく手法。

- [[http://e-words.jp/w/E6A78BE980A0E58C96E38397E383ADE382B0E383A9E3839FE383B3E382B0.html][構造化プログラミングとは 【 structured programming 】 ： IT用語辞典]]

「制御の流れ」を構造化しただけであり、
「データ構造」には何の制限や規則も設けていない。

「芸術品」から脱却して「工業製品」へ遷移すること、
あるいは、「処理性能重視」から「保守性重視」へ向かったもの。
別の見方をすれば、処理効率を犠牲にして、作りやすさや理解容易性を求めたもの。

- [[http://monoist.atmarkit.co.jp/mn/articles/1009/17/news118.html][構造化プログラミングからオブジェクト指向への進化 - MONOist（モノイスト）]]

** 三つの構造化文
ダイクストラが提唱。

- 順次
順接、順構造とも言われる。
プログラムに記された順に、逐次処理を行なっていく。
プログラムの記述とコンピュータの動作経過が一致するプログラム構造である。

- 反復
一定の条件が満たされている間処理を繰り返す。

- 分岐
ある条件が成立するなら処理Aを、そうでなければ処理Bを行なう。 

* Object-Oriented Programming
オブジェクト指向型プログラミング

** Data abstraction
*** Encapsulation
カプセル化。

** Polymorphism
** Inheritance

* Detarministic dataflow programming
決定性データフロープログラミング。

* 
* Multi-agent dataflow programmming
マルチエジェーントデータフロープログラミング。

* Concept(コンセプト) 未整理

*** List,trees, and records
*** Symbolic programming
*** Instantiation
*** Genericity
*** Kernel languages
*** Abstract machines
*** Mathematial semantics
*** Exception handling
*** Dataflow synchronizaton
*** Deterministic concurrency
*** Nondeterminism

