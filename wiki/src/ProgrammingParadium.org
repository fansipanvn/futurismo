#+OPTIONS: toc:nil
* プログラミングパラダイム

- [[http://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%91%E3%83%A9%E3%83%80%E3%82%A4%E3%83%A0][プログラミングパラダイム - Wikipedia]]

* 基本コンセプト
** Identifiers and environments
識別子と環境。

x = 1 ということはどういうことかを説明する概念。

数学的な写像関係で x = 1 を説明しようとしている。{ X -> x1=1 }みたいな感じ。
x1がメモリ上の実際の(束縛された)値で、Xがそれを指し示す識別子。

その写像関係を環境という。

** Scope
Valiableの有効範囲。

** State
State(状態）とは、必要とされる計算の途中結果を含む、値の時系列。
(sequence of values calculated progressively,
which contains the intermediate results of a computation)

状態の導入によって、プログラムに時間の概念を与える。

** Operational Semantics
wikipedia: [[http://ja.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%9A%84%E6%84%8F%E5%91%B3%E8%AB%96][操作的意味論 - Wikipedia]]
    
プログラムの正しさを数学的に証明することを目指す。

- Specification ・・・ プログラムの入力と出力を定義したものを
- Program ・・・ プログラミング言語によってかかれたデータ

ProgramがSpecificationを満たしているかを証明する。そのために、

- Semantic(意味の対応付け）
- Abstruct Machine(抽象化された実行環境）

という概念を導入する。Programはkernel Languageに分解され、Kernel Language
の構成要素がAbstruct Machineと対応付けられる。

#+begin_src language
                             Semanitic 
    Program --> kernel Language ----->  Specification
                            Abstrucut Machine
#+end_src

プログラミングが正しいことは、数学的帰納法(mathematical induction)で証明する。

*** example
**** Specification
      
#+begin_src language
0! = 1
n! = n×(n-1)!  when n>0
#+end_src

**** Program

#+begin_src oz
fun {Fact N}
   if N==0 then 1 else N*{Fact N-1} end
end
#+end_src

**** Semanitc Expression

#+begin_src language
E={Fact→fact, N→n, R→r} (AbstcutMachine)
σ={fact=(proc ... end,CE),n=0,r} (memory)
CE={Fact→fact}. ( Contectual Environment)

{Fact N R}, E, σ
#+end_src


* Functional programming
関数型プログラミング。

すべての計算や処理などを関数の定義の組み合わせとして記述していくタイプのプログラミング言語。

「同じ入力には必ず同じ出力を返す」「関数の評価が他の関数に影響を及ぼさない」など
数学における関数と似た性質を持った関数の定義としてプログラミングを行い、
プログラムの実行は記述された関数群の評価として行われる。

- [[http://ja.wikipedia.org/wiki/%E9%96%A2%E6%95%B0%E5%9E%8B%E8%A8%80%E8%AA%9E][関数型言語 - Wikipedia]]
- [[http://e-words.jp/w/E996A2E695B0E59E8BE8A880E8AA9E.html][関数型言語とは 【 functional language 】： IT用語辞典]]


- 広義の意味では、Whatをコンピュータに示すもの（Howを示さない）。
- 狭義の意味では、プログラミングの中で数学を用いたもの(Function, Relation)。

** Impliclite(declarative) State
暗黙的状態。宣言的状態ともいう。

- 関数の実行結果が値をもつ
- Explicite Stateとの対概念。
- 関数型プログラミングの特徴。

** Recursion
再帰的プログラミング。

*** accumulater
C++の、numericライブラリ(accumuulateなど)で利用されている。

スタックのサイズが均一なことが特徴的。

*** tail-recursion(末尾再帰）
その中にただ1つの再帰呼び出しがあり、
かつその呼び出しが手続き本体の最後にあるもの。

#+begin_src C++
state whileLoop(state s) {
  while (!isDone(s)) // 終了条件
    s = transform(s) // 再帰
  return s;
}
#+end_src

*** invariant programming(不変式プログラミング)
再帰的に呼ばれる度に、数学的に真になる式。

- [[http://ja.wikipedia.org/wiki/%E4%B8%8D%E5%A4%89%E6%9D%A1%E4%BB%B6][不変条件 - Wikipedia]]

*** Higher-order programming
高階プログラミング。procedure valueをサポートしている言語でのプログラミング技術。
関数を引数としてわたす能力。

Rubyではlambda, procなど。C言語には関数ポインタがある。C言語は2階。

* Declarative Programming
宣言型プログラミング。

- [[http://ja.wikipedia.org/wiki/%E5%AE%A3%E8%A8%80%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0][宣言型プログラミング - Wikipedia]]

- Imperative Programingの対になる概念。
  "Function without State"

- Imperative vs Declaretive is also Stateful vs Stateless
  
HTMLはStateless、Declarative Programming language.
状態はクッキーを導入してしばしば実現する。

** 主な言語
- HTML
- MySQL
  
* Imperative Programming
命令型プログラミング。

- [[http://ja.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0][命令型プログラミング - Wikipedia]]

Imperative programmingとは、Function paradigmにCellの概念を加えたもの。

- 手続き型プログラミングと同義のこともある。
- Declarative Programingの対になる概念。
  Imperative vs Declaretive is also Stateful vs Stateless

#+begin_src language
Imperative programming = Function paradigm + Cell
#+end_src

- 実行するたびに、内部の状態によって結果がことなる。

** Explicite State
明示的状態。

- 生存期間が2度以上の手続的呼び出しに渡るような一つの状態。
- 関数の実行の中に値をもつ。
- 手続きの引数に現れないもの。

同様なことを関数型パラダイムで実現するためには、仮引数に状態を持たないといけない。

** Cell
Explicite State(明示的状態)を表す基本型。二つの構成要素からなる。

- 名前値(Vaiue)
- 単一代入格納域への参照(Identifier)

#+begin_src oz
declare
fun {Reverse L}
   % 空リストのcellを生成
   Rs = {NewCell nil}
in
   % リストの各要素を取り出して内部Cellに結合
   for X in L do
      Rs := X|@Rs
   end

   % 内部セルをリターンする。
   % Rubyっぽい！
   @Rs
end

{Show {Reverse [1 2 3 4]}}
#+end_src

Function ParadigmsとImperative Paradigmの違いは、

- Function 
  - 状態変化しない(Immunity)
  - 機能追加時にインタフェースの変更の影響度がおおきい。
- Inperative
  - 機能追加時にインタフェースの変更の影響度がない。(モジュール性）
  - 状態変化する。

** 主な言語
- C言語

* Structured programming
構造化プログラミング。

[[http://ja.wikipedia.org/wiki/%E6%A7%8B%E9%80%A0%E5%8C%96%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0][- 構造化プログラミング - Wikipedia]]

** 三つの構造化文
ダイクストラが提唱。

- 順次
順接、順構造とも言われる。プログラムに記された順に、逐次処理を行なっていく。プログラムの記述とコンピュータの動作経過が一致するプログラム構造である。

- 反復
一定の条件が満たされている間処理を繰り返す。

- 分岐
ある条件が成立するなら処理Aを、そうでなければ処理Bを行なう。 

* Object-Oriented Programming
オブジェクト指向型プログラミング

** Data abstraction
*** Encapsulation
カプセル化。

** Polymorphism
** Inheritance

* Detarministic dataflow programming
決定性データフロープログラミング。

* Multi-agent dataflow programmming
マルチエジェーントデータフロープログラミング。
* Concept(コンセプト) 未整理

*** List,trees, and records
*** Symbolic programming
*** Instantiation
*** Genericity
*** Kernel languages
*** Abstract machines
*** Mathematial semantics
*** Exception handling
*** Dataflow synchronizaton
*** Deterministic concurrency
*** Nondeterminism

