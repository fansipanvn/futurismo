#+OPTIONS: toc:nil
* Object-Oriented Programming
  オブジェクト指向型プログラミング.
  - [[http://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0][オブジェクト指向プログラミング - Wikipedia]]

  CTMCP, Chapter 6,7

** 手続き型とオブジェクト指向の違い
*** 機能分解
    ある問題を小さな機能にブレークダウンすることで, 
    その問題を構成する機能要素の洗い出しをすることを機能分解と呼ぶ.
    
**** 構造化プログラミング的アプローチ
      - (手続き的な) 機能を適切な順序で呼び出す「メイン」プログラムが必要になる.
      - メインプログラムにはすべてを正しく動作させる, 
       	すなわち機能の組み合わせと呼び出し順序を制御するあまりに大きな責任が課せられる
      - 結果的にソースコードは複雑になる
	 
**** オブジェクト指向的アプローチ
     - 部分機能に対してそれ自体の振舞いに関する責任を持たせ, 
       実行指示を行うだけであと任せておく. 
     - これが委譲 (delegation) という考え方.


* Data abstraction
  データ抽象. 3 つの構成要素がある.
  - Input
  - Output
  - Interface

  データ抽象は内部と外部からなるプログラムかつ, 
  両者がインターフェースを通じてやりとりするもの.

  A data abstraction is a part of a program that has an inside, an outside,
  and an interface in between The inside is hidden from the outside.

  データを抽象的に使う, 使い方.実装にとらわれずにデータを使うこと.
  インタフェースと呼ばれる規則にしたがって使用される具体化の集合.

  データ抽象を型 (Type) といって済ますこともある.
  抽象データ型 (ADT) は, 特殊なデータ抽象.
  値の集合と, それに関する操作の集合.(CPMCP p431)

  以下のコンセプトに支えられている
  - High-order Programming (高階関数)
  - Static Scoping (クロージャ)
  - Explicit State (明示的状態)

  Data Abstruction は 2 つの実現方法がある.
  - Abstruct Data Type (ADT)
    値と操作をベツベツに保持する.
  - Object
    値と操作を一緒に保持する

** Input/Output
   内部は外部からは隠蔽されている. -> カプセル化という.

   The inside is hidden from the outside

** Interface
   The interface is a set of operations that an be used according to certain rules.

   データ抽象には, 主に二つの方法がある.
   - Abstract Data Type (ADT) keeps values and operations separate.
   - Object groups together value and operations in a single entity.

   Java インタフェースは, 階層を持たない型システムを構築する.
   (Effective Java p91 抽象クラスよりもインタフェースを選ぶ)

*** 抽象クラスよりもインタフェースを選ぶ
    Effective Java (p93)
     実装の観点では,
     + 抽象クラスはメソッドに対する実装を含むことを許されている.
     + インタフェースはメソッドに対する実装を含むことを許されていない.

     機能の観点では,
     + 抽象クラスはある機能の実装を強制する.
     + インタフェースは任意の機能を混ぜ合わせる.

     階層化の観点では, 
     + 抽象クラスは物事を階層化することに優れる.
     + インタフェースは階層を持たないものをまとめることに優れる.

     インタフェースは, 階層を持たない型システムを構築する.

     - インタフェースは型を定義するために利用する
     - インタフェースは定数を提供するために使用しない
       + Enum を検討する
       + Util クラスを検討する
       + 関連するクラスのメンバを検討する

** Encapsulation
   プログラムと内部と内部をインタフェースで分けること.
   カプセル化のメリットは大規模開発をシンプルにする.
   - 正しさを保証する.
   - 複雑さを解消する.

*** カプセル化とはあらゆるものを隠蔽すること
    カプセル化がデータ隠蔽というのは狭義の定義.

    カプセル化とはあらゆるものを隠蔽すること.
    - データ
    - メソッド
    - 実装
    - 派生クラス
    - 設計の詳細
    - 実体化の規則
    - 型

    流動的要素を探し出してカプセル化する

*** 某 氏の発言
    ある目的をもったモノの集合.(N 氏)
    モノには特性 (属性と操作) がある.
  
    アプリケーションを設計するということは,
    まずそのアプリケーションで利用される
    データ型を定義するということからはじめる. 
    (AplInteger, AplString みたいなもの)

    その後, 自分が定義したデータ型を操作するインタプリタを設計する.

    実装では, Java をつかっているものの,
    Java はそれらの抽象データ型のインタプリタでしかない.

    抽象データとインタプリタを設計することが設計.
    ->(内部 DSL のこと?? ドメインモデル設計)

* Abstract Data Type
  抽象データ型. ADT と略されることも.
  
  構造化プログラミングは仮想機械モデルに基づく
  段階的詳細化法 (stepwise refinement) をもたらしたが,
  データ構造の変更を行うと変更部分がソースコード中に散在してしまうという弱点があった.
  データ抽象の概念はその欠点を補完するものであった
  
  - [[http://ja.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B][抽象データ型 - Wikipedia]]

  An ADT consists of a set of values and a set of operations.
    - Integer 型
    - Value:1,2,3
    - Operation:+
    - Stack 型
    - Value: elemtent
    - Operation: push, pop, ...

    Value と Operation それ自体は State を持たない.
    CTM, p433

  バンドルされていないデータ抽象.

** ラッパー
   ADT に アクセスするための key (キー) を導入することで,
   安全にアクセスすることができる.
   
   
   値の集合に直接アクセスさせないための操作.(CPMCP p210)
   - 値を安全に保持するためには, 
      鍵 (key) を利用して (包む) 操作を追加すればよい.
      
#+begin_src oz
Key={NewName}
SS={Chunk.new w (Key:S)}
#+end_src

    包み, ほどきを行うデータ抽象をラッパーと定義する.

    #+begin_src oz
proc {NewWrapper ?Wrap ?Unwrap}
   Key={NewName} in
   fun {Wrap X}
      {Chunk.new w{Key:X}}
   end
   fun {Unwrap X}
      try W.Key catch _ then raise error (unwrap (W)) end end
   end
end
    #+end_src

以下のように, Wrap, Unwrap する.

#+begin_src oz
S={a b c}
SS={Wrap S}
S={Unwrap SS}
#+end_src

** Example
    Diference between ADT and Object. Stack をつかった実装の違い.
*** ADT
    #+begin_src oz
local Wrap Unwrap in
  {NewWrapper Wrap Unwrap}
  fun {NewStack} {Wrap nil} end
  fun {Push W X} {Wrap X|{Unwrap W}} end
  fun {Pop W X} S={Unwrap W} in X=S.1 {Wrap S.2} end
  fun {IsEmpty W} {Unwrap W}==nil end
end
    #+end_src

    この手法は Stateful ADT という.

    そして, C 言語では, こうやってデータ抽象化を行うことがおおい.
    もちろん関数ポインタ配列を使えば C 言語でも Object をつくることができるが,
    実際にはそこまでやらない. (面倒)

*** Object
    オブジェクトでは, データに対する操作はプロシージャ変数として扱われることに注目.

    #+begin_src oz
fun {NewStack}
  C={NewCell nil}
  proc {Push X} C:=X|@C end
  proc {Pop X} S=@C in X=S.1 C:=S.2 end
  fun {IsEmpty} @C==nil end
in
  stack (push:Push pop:Pop isEmpty:IsEmpty)
end
    #+end_src

    オブジェクト指向言語は,
    単に Object をサポートする言語ではなくて, 
    Abstruct Data Type も強力にサポートしている.

    Object と ADT の意味がごっちゃにつかわれているのが現実の現状.

** Bookmarks
   - 比較的わかりやすい: [[http://www.hitachi.co.jp/Prod/comp/soft1/manual/pc/d645140/W4510070.HTM][抽象データ型]


** Enum: 列挙型
   プログラマが選んだ各々の識別子をそのまま有限集合として持つ抽象データ型.
   - [[http://ja.wikipedia.org/wiki/%E5%88%97%E6%8C%99%E5%9E%8B][列挙型 - Wikipedia]]

   番号を持たないカテゴリ変数. 一意の文字.

   
   実行時には, 番号が振られることが覆いが, 
   言語によっては番号はプログラマに見えないこともある.

* Object-Oriented Paradiums
  以下の要素をそなえもつ
  - Data Abstraction
  - Inheritance
  - Polymorphism

  現在オブジェクト指向言語と呼ばれているものは,実際には,
  - Abstruct Data Type (Java Integer 型)
  - オブジェクト (Java Object 型)
  の 2 つを合わせもっている.

  その意味で, オブジェクト指向言語と言うよりは,
  抽象データ言語というほうが正しい.

** Object
   値と操作をひとつのまとまりとしたもの. 以下の構成要素をもつ.
   - 値 ・・・ Explicite State (明示的状態)
   - 操作 ・・・ Procedural Data Abstruction (手続的データ抽象)

*** メソッドと属性
    オブジェクトは内部と外部はインタフェースを通じてやりとりされる.
    内部の明示的状態を Attributes (属性), 
    インタフェースを Methods (メソッド) という.
   
    たとえば, A1 を属性, M1 をメソッドという.

#+begin_src oz
declare
local
   A1={NewCell 0}
in
   proc {M1 Hoge} end
end
#+end_src

  これはクラスでもインスタンスでもないことに注意!!

** Class
   抽象データからなるデータ構造.

   メソッドと属性を定義する特別なシンタックスを Class という.
   属性とメソッドはレコードデータ構造によって管理されているだけである!

   Class とは, Pair ( attrs[属性の集合] : methods[メソッドの集合]) )
   
   または, Java ならば, こうかいてもいい.

   #+begin_src java
   HashMap<String, HashSet<String>> attrs = new HashMap<String, HashSet<String>>();
   HashMap<String, HashSet<String>> methods = new HashMap<String, HashSet<String>>();

   attrs.put ("Hoge", new HashSet (Arrays.asList ("attr1", "attr2")));
   methods.put ("Hoge", new HashSet (Arrays.asList ("method1", "method2")));
   #+end_src

   Class という概念によって, オブジェクトの"宣言"と"生成 (new)"を分離する.
   - [[http://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%A9%E3%82%B9_(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF)][クラス (コンピュータ) - Wikipedia]]

   クラスは, 継承・ポリモーフィズム・カプセル化などの, 
   オブジェクト指向プログラミングにおける重要な概念を実現する強力な手段.

** Instantiation
   オブジェクトは一つのメソッドで,
   異なる属性をもつ複数のオブジェクトを生成できる.
   
   この能力を Instantiation (インスタンス化) という.

** Procedure Dispatch
   オブジェクトは単一なエントリポイントをもつ. (エントリポイント = 呼び出し口)
   エントリポイントに渡される引数をメッセージという.

   下の例だと, Counter がエントリポイント. エントリポイントに inc,get メッセージを送る.

   #+begin_src oz
   {Counter inc}
   {Counter get (X)}
   #+end_src

   エントリポイントから, メッセージに対応するプロシージャが呼びだされる.

   メッセージとプロシージャはあらかじめ Dispatch (バンドリング) されている.

** Polymorphism
   各要素 (定数, 変数, 式, オブジェクト, 関数, メソッドなど) 
   についてそれらが複数の型に属することを許すという性質.
   - [[http://ja.wikipedia.org/wiki/%E3%83%9D%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%95%E3%82%A3%E3%82%BA%E3%83%A0][ポリモーフィズム - Wikipedia]]

*** interface
    抽象データ型のメソッド.

    Object 型を分類し,
    同じカテゴリに属するクラスに共通のインターフェイスを取り決める.
    - [[http://homepage1.nifty.com/CavalierLab/lab/vb/clsmdl/polymorphism_02.html][ポリモーフィズムとインターフェイス]]
      
** Inheritance
   継承. あるオブジェクトが他のオブジェクトの特性を引き継ぐこと.

   - [[http://ja.wikipedia.org/wiki/%E7%B6%99%E6%89%BF_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)][継承 (プログラミング) - Wikipedia]]

** Delegation
   委譲.あるオブジェクトの操作を一部他のオブジェクトに代替させる手法.
   - [[http://ja.wikipedia.org/wiki/%E5%A7%94%E8%AD%B2][委譲 - Wikipedia]]

*** 特徴
    - 委譲を行うオブジェクトは委譲先オブジェクトへの参照を持つ
    - 必要に応じてその参照を切り替える事で動作にバリエーションを持たせる事ができる
    - プラグイン機構

*** コンポジショントデリゲーション
    - 委譲の実現には多くの場合コンポジションを使用する.
      委譲は「目的」であり, コンポジションはその「手段」.

    参考:
    - [[http://d.hatena.ne.jp/earu/20100525/1274794979][コンポジションとデリゲーション - とある技術メモブログ]]

**** Composition
     コンポジション. 新たなクラスに, 既存クラスのインスタンスを保持する.
     has-a の関係 (not is-a)

     Prefer Composition over inheritance (Effective Java).

*** 継承との比較
**** メリット
    - Java の場合継承は一クラスしかできないが, 委譲なら複数可能
    - 継承なら親クラスのメソッドが全て公開されてしまうが, 
      委譲なら必要なものだけ公開できる
**** デメリット
    - 継承に比べてコードの記述量が多くなる.
      継承は何も書かなければ親クラスの機能が使える.
      委譲はメソッドの呼び出しを実装しなくてはならない.

    - eclipse では, 右クリック→ソース→委譲メソッドで簡単に作成できる.
    - Ruby には delegation のライブラリがある.
      [[http://qiita.com/w650/items/671cc9c49b2ebf60620d][Ruby で delegation (委譲) を簡単にする 2 つの方法 - Qiita]]

   参考:
    - [[http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q14103428069][オブジェクト指向で. 継承の他に, 委譲といのが出てきますが. これは具... - Yahoo! 知恵袋]]

*** 関連する Design Pattern
    - Adapter
    - Proxy
    - Facade
    - State
    - Strategy
    - Decorator
    - ほかにもあるかな...

    参考:[[http://lab.tricorn.co.jp/toda/1088][Tricorn Labs » State パターンと Strategy パターンは何が違うのか考える]]


* オブジェクト指向のこころより
** OOP の 2 大原則
   オブジェクト指向のこころとは, ズバリ以下だ.
    - 流動的要素を探し出してカプセル化する
    - クラス継承よりもオブジェクトの集約を多用する

** オブジェクト指向設計
   - [[http://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E5%88%86%E6%9E%90%E8%A8%AD%E8%A8%88][オブジェクト指向分析設計 - Wikipedia]]

*** 名詞/ 動詞 抽出法
    - 問題領域に存在する名詞を洗い出し,
      それらを表現するオブジェクトを生成する.
    - 名詞に関連した動詞を洗い出し,
      それらを表現するメソッドを追加する

*** 共通性/ 可変性 分析法
    - 共通性分析:時間が経っても変化しにくい構造を見つけるもの
      共通性分析によってまとめられた概念を抽象クラスによって表現
    - 可変性分析:変化しやすい構造を洗い出すもの
      可変性分析で得た流動的要素は抽象クラスの派生クラスによって実装される

    設計手順:
    - (抽象クラス) このクラスが持つ責務をすべて全うするにはどうようなインターフェイスが必要か?
    - (派生クラス) この特定実装の中でどうのようにして与えられた仕様を実装できるのか?

    Jim Coplien が提唱. p235 第 15 章から抜粋.

**** Links
    - [[http://d.hatena.ne.jp/asakichy/20090428/1240878836][オブジェクト指向の本懐 (7) ・オブジェクト指向分析 - Strategic Choice]]
    - [[http://shoheik.hatenablog.com/entry/20120917/1347838230][共通性・可変性分析 (commonality/variavility analysis) - Debuginfo]]

* Bookmarks
  ものすごくよい記事.歴史が端的にまとまっている.
  - [[http://qiita.com/hirokidaichi/items/591ad96ab12938878fe1][新人プログラマに知っておいてもらいたい人類がオブジェクト指向を手に入れるまでの軌跡 - Qiita]]

  #+BEGIN_QUOTE
  むだに Hoge インタフェースと HogeImpl クラスがあったり,
  むだに new するだけの create メソッドがあったり,
  どこで値が設定されてるかわからないオブジェクトがひきまわされてたり,
  ソースコードを追いにくくするためにやってるとしか思えない,
  オブジェクト指向なコードをよく目にする.

  クラスは単にユーザー定義型であり,
  継承は部分型と差分プログラミングを実現する仕組みだととらえるのがいい.
  オブジェクトがメッセージを送りあうとかメルヘンの世界には入らず, 機能だけ考えるのがいい.
  #+END_QUOTE

  - [[http://d.hatena.ne.jp/nowokay/20140718#1405691217][オブジェクト指向は禁止するべき - きしだのはてな]]

** Rees
  - [[http://practical-scheme.net/trans/reesoo-j.html#][Rees Re: OO]]

 オブジェクト指向というのは, このリストのいろいろなサブセットとして 定義されているようだ.
 つまり, 「オブジェクト指向」というのはちゃんと定義された概念ではない!

*** カプセル化
    型の実装を構文的に隠蔽できること. 例えば C や Pascal では何かが構造体
    であるか配列であるか常に意識することに なるが, CLU や Java ではその違
    いを隠すことができる.
    
*** 保護 
    型の使用者がその実装をのぞくことができないこと. これによって,
    ふるまいさえ変えなければ, 実装を変更しても型の使用者に 影響を与えな
    いことが保障でき, またパスワードのような情報が漏れ出さないように す
    ることもできる.

*** アドホックポリモルフィズム
    関数やパラメータつきデータ構造が たくさんの異なる型の値をとることができる.

*** パラメトリックポリモルフィズム
    関数やデータ構造が任意の値 (例:任意のオブジェクトのリスト) に対してパ
    ラメタライズできること. ML と Lisp はこれを持つ. Java は非 Object な
    型のために, これを完全に持つとは言えない.
    
*** 全てはオブジェクトなり 
    全ての値はオブジェクト. Smalltalk では真だが, Java では (int 等のため) 真ではない.

*** メッセージを送ることだけができる (All you can do is send a message,
    AYCDISAM) = Actor モデル 
    オブジェクトを直接いじることはできず, それと通信する, もしくはそれを
    起動する ことのみができる. Java における field の存在はこれに反する.
    
*** 仕様継承 = サブタイピング 
    ふたつの異なる型で, 一方の型の値が もう一方の型の値として使われても型
    の正当性を破らないことを言語が保障できるような もの. (例: Java のイン
    タフェース継承).
    
*** 実装継承, 再利用 ひとまとまりのコードを書いたら, それと似たコード
    (そのスーパーセット) が制御された方法で生成できる. つまりコードをコ
    ピーして編集する必要がない. 制限された, 特殊な抽象化である. (例:
    Java のクラス継承).

*** 「関数の積和 (sum-of-product-of-function) 」パターン 
    オブジェクトは (実質的に) 有限の簡単な名前の集合から選ばれるキー引数
    を第一引数に取り, それによってメソッドを呼び出す関数として動作する.
