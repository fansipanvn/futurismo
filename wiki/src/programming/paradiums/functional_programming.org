#+OPTIONS: toc:nil
* Functional Programming
  関数型プログラミング.

  - [[http://ja.wikipedia.org/wiki/%E9%96%A2%E6%95%B0%E5%9E%8B%E8%A8%80%E8%AA%9E][関数型言語 - Wikipedia]]

  すべての計算や処理などを関数の定義の組み合わせとして
  記述していくタイプのプログラミング言語.

  「同じ入力には必ず同じ出力を返す」「関数の評価が他の関数に影響を及ぼさない」など
  数学における関数と似た性質を持った関数の定義としてプログラミングを行い,
  プログラムの実行は記述された関数群の評価として行われる.

  - [[http://e-words.jp/w/E996A2E695B0E59E8BE8A880E8AA9E.html][関数型言語とは 【 functional language 】: IT 用語辞典]]

  広義の意味では, What をコンピュータに示すもの (How を示さない).
  狭義の意味では, プログラミングの中で数学を用いたもの (Function, Relation).

  - 式と関数でプログラムを組み上げる (Use of MathMatics)
  - 関数を値として扱える (Higher-order programming)
  - 副作用を起こさない (Impliclite State, Stateless)

  - [[http://itpro.nikkeibp.co.jp/article/COLUMN/20110411/359286/?ST=develop&P=3][3 つのプログラミングのパラダイムを押さえておこう:ITpro]]

  CTMCP, Captor 2

  関数が第一級オブジェクトである言語.

** 定義
   狭義の意味では,
   - 状態をもたない
   - 一時変数を持たない
   - loop を持たない
   - 手続的制御構造を持たない

   広義の意味では, 
   - 関数に focusing したプログラミング.

** 計算の考え方
   命令型では, 計算の基本は蓄えられている値を変えること.

   関数型では, 計算の基本は引数に関数を適用すること.

** Languages
   - 狭義の意味では Lisp, XPath, Haskell,,,
   - 広義の意味では, Scheme, Clojure, ocame, F#, Scala, Smalltalk, Ruby...

** メリット
   関数プログラミング実践入門からの引用
   - コード量が少なくなる 
   - 最適化がしやすい 
   - 並列処理が書きやすい 
   - バグりにくい
   - ドキュメントが少なくなる

* Immunity
  副作用を起こさない.

** Implicate (declarative) State
   暗黙的状態. 宣言的状態, Stateless, ともいう.

   - 関数の実行結果が値をもつ
   - 同じ入力には必ず同じ出力を返す.
   - Explicite State との対概念.
   - 参照透明性.

*** Referential Transparency: 参照透過性
    式の値はその構成要素 (例えば変数や関数) によってのみ定まる.
    - [[http://ja.wikipedia.org/wiki/%E5%8F%82%E7%85%A7%E9%80%8F%E9%81%8E%E6%80%A7][参照透過性 - Wikipedia]]

**** example
   - 変数の値は最初に定義した値と常に同じ
   - 関数は同じ変数を引数として与えられれば同じ値を返す

*** pure function: 純粋関数
    同じ引数を渡す限り, 
    どのような順番で何度呼んでも同じ結果が返るような関数.

    同じ式を評価すると, いつも同じ結果になる参照透過性を持っていること.

    副作用がある関数の対概念.

** Side effect: 副作用
   ある機能がコンピュータの (論理的な) 状態を変化させ, 
   それ以降で得られる結果に影響を与えること.
  - [[http://ja.wikipedia.org/wiki/%E5%89%AF%E4%BD%9C%E7%94%A8_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0)][副作用 (プログラム) - Wikipedia]]

  あるいは,
  - 状態を参照することで出力が変化すること
  - 状態に変化を与えることで出力が変化すること

  例としては,
   - 破壊的代入
   - I/O 制御 (write/print 等)

*** 破壊的代入
    代入というのは, 「右辺にあるものを左辺に代入する」という意味. 

    左辺にある変数内のデータを消し, 
    新しく右辺にあるデータを代入する」とも言い換えられます. 
    この仕組みのことを「破壊的代入」という.

** モナド
   wikipedia, なにいっているかわからない.
   - [[http://ja.wikipedia.org/wiki/%E3%83%A2%E3%83%8A%E3%83%89_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)][モナド (プログラミング) - Wikipedia]] 

   以下のような問題は, という概念で説明できるらしいが, 結局よくわからない.
   - 入出力等をもたらすプログラム
   - 例外を返すプログラム
   - 引数に対して値を返さない (停止しない) プログラム
   - 同じ引数でも返り値が異なる可能性のあるプログラム

   値およびその値を使う計算の並びという観点からいえば, 計算を構造化 する方法
   - [[http://www.sampou.org/haskell/a-a-monads/html/introduction.html][Introduction]]

   -> 詳細は Haskell の章に移動.

** List Comprehensions
   リスト内包表記.
   既存の集合から新しい集合を生成する.

   - 生成器 ... 集合からの取り出しかたの定義
   - ガード ... 生成する条件

** impelative paradigm との違い

*** impelative paradium
    - ループで反復構造を実行
    - 異なる関数の間で共有する状態を変更

    #+begin_src scala
var i = 0
while (i < args.length) {
  if (i != 0) {
    print (" ");
  }
  print (args (i));
  i += 1;
}
println ();
    #+end_src

*** functional paradium
    - 再帰で反復構造を実行
    - arg は変数ではなくて, 不変な定数

    #+begin_src scala
args.foreach (arg => println (arg))

for (arg <- args)
  println (arg)
    #+end_src

* Higher-order programming
  高階プログラミング.

  procedure value をサポートしている言語でのプログラミング技術.
  - 関数を引数としてわたす能力.
  - 関数を戻り値としてかえす能力.

** クロージャ
   引数以外の変数を実行時の環境ではなく, 
   自身が定義された環境 (Static Scope) において解決する.
  - [[http://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3][クロージャ - Wikipedia]]

  Procedure Value (Oz), Lexical Scoped Closure ともいう.

  関数とそれを評価する環境のペアとも言える.
  Procedure value は ペアでメモリ上の値にバインドされる.
  - Procedure code
  - Contextual environment

*** Contextual environments
    関数の内部で参照されていて, 関数の外部で宣言されているすべての
    識別子の集合を,その関数の contextual environments という.

*** 各言語での実現方法
    - Java ... 無名クラス

** 関数の order
   帰納的な定義.

   - first order
   A function whose inputs and output are not functions.
   - Nth order
   if its inputs and output contain a function of maximum order N.

   C 言語には関数ポインタがある. 
   C 言語は 第二級オブジェクト. 2 階関数.

*** First Class:  第一級オブジェクト
    たとえば生成, 代入, 演算, (引数・戻り値としての) 受け渡しといった
    その言語における基本的な操作を制限なしに使用できる対象のこと.
    - [[http://ja.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E7%B4%9A%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88][第一級オブジェクト - Wikipedia]]

    以下のような特徴をもつ (関数プログラミング実践入門)
    - リテラルがある
    - 実行時に生成できる
    - 変数に入れて扱える
    - 手続きや関数の引数として与えることができる
    - 手続きや関数のの結果として返すことができる.

    関数型言語とは, 関数が第一級オブジェクトであること.

*** Genericity
    引数に関数を受け取るもの.

    #+begin_src oz
declare
fun {Map F L}
   case L of nil then nil
   [] H|T then {F H}{Map F T}
   end
end
    #+end_src

*** Instantiation
    戻り値に関数を渡すもの.

#+begin_src oz
declare
fun {MakeAdd A}
   fun {$ X} X+A end
end
#+end_src

** 有名な例
*** map
    リストの各要素に関数を適用する.

#+begin_src haskell
Prelude> map (+1) [1,3,5,7]
[2,4,6,8]
#+end_src

*** filter
    リストの各要素で条件に一致したものを取り出す.

#+begin_src haskell
Prelude> filter even [1..10]
[2,4,6,8,10]
#+end_src

*** fold

** 関数オブジェクト.
  関数をオブジェクトとしたもの.
  関数閉包. 関数オブジェクト (function object) とも言う.
  - [[http://ja.wikipedia.org/wiki/%E9%96%A2%E6%95%B0%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88][関数オブジェクト - Wikipedia]]

*** ラムダ式

**** Language
     - Ruby: lambda{|x, y| x + y}
     - Scala:
     - Haskell:

*** デリゲート
    オブジェクトへの参照と関数オブジェクトへの参照をペアにして持つもの.
    C#, Visual Basic .NET などの, .NET Framework のプログラミング言語にある機能.
    - [[http://ja.wikipedia.org/wiki/%E3%83%87%E3%83%AA%E3%82%B2%E3%83%BC%E3%83%88_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)][デリゲート (プログラミング) - Wikipedia]]

** Annonimous Functions
   無名関数. 名前付けされずに定義された関数.
   Function Literal (関数リテラル), 匿名関数といわれることもある.
   - [[http://ja.wikipedia.org/wiki/%E7%84%A1%E5%90%8D%E9%96%A2%E6%95%B0][無名関数 - Wikipedia]]

*** メリット
    - 一度しか使わない関数の名前を付けなくて済む.
    - 名前の衝突を考えなくて済む.
    - 関数の引数などに直接渡せる

*** Language
    - Ruby {|x, y| x + y}
    - Scala (x :Int, y :Int) =>  x + y , (x, y) => x + y
    - Haskell \ x y -> x + y

** 関数値, 関数オブジェクト, クロージャ, ラムダ式, 無名関数の整理
   - 関数値:
   - 関数オブジェクト:
   - クロージャ: 変数束縛が閉じられた関数オブジェクト
   - ラムダ式:
   - 無名関数:

** Currying
   カリー化. 複数の引数をとる関数を,

   - 引数が「もとの関数の最初の引数」で
   - 戻り値が「もとの関数の残りの引数を取り結果を返す関数」

   であるような関数にすること.

   - [[http://ja.wikipedia.org/wiki/%E3%82%AB%E3%83%AA%E3%83%BC%E5%8C%96][カリー化 - Wikipedia]]

   部分適用を容易にすることが可能になるというメリットがある.

* invariant programming
  不変式プログラミング. 再帰的に呼ばれる度に, 数学的に真になる式.
  - [[http://ja.wikipedia.org/wiki/%E4%B8%8D%E5%A4%89%E6%9D%A1%E4%BB%B6][不変条件 - Wikipedia]]

** Recursion
   再帰的プログラミング.

** tail-recursion
   末尾再帰.

   その中にただ 1 つの再帰呼び出しがあり,
   かつその呼び出しが手続き本体の最後にあるもの.


   関数がそれ自身を最後の処理で呼び,
   かつ, 関数のスタックが再利用されるもの.

   tail-recursion の例. Factorial

   #+begin_src oz
declare
fun {Fact N}
   local Fact1 in
      % tail-recursive でない
      % 計算のたびにスタックがたまる.
      fun{Fact1 N}
	 if N==1 then 1
	 else N*{Fact1 N-1}
	 end
      end
   
      local Aux in
      % tail-recursive
      % 計算のたびにスタックがたまらない.
	 fun {Aux N Acc}
	    if N==0 then Acc
	    else {Aux N-1 {Fact1 N}|Acc}  % call Fact on N here!!!
	    end
	 end
	 {Aux N nil}
      end
   end
end
   #+end_src

*** State pattern
    関数型パラダイムでの実装

    #+begin_src oz
fun {While S}
  if {isDone S} then S
  else {While {Transform S}} end /* tail recursion */
end
    #+end_src

    手続き型パラダイムでの実装

    #+begin_src C++
state whileLoop (state s) {
  while (!isDone (s)) // 終了条件
    s = transform (s) // 再帰
  return s;
}
    #+end_src

** Accumulator
   C++ の, numeric ライブラリ (accumuulate など) で利用されている.

   スタックのサイズが均一なことが特徴的.

** Specification

** Principle of communicating vases
  
   #+begin_src oz
% principle of communicationg vases
% n! = i! * a
%    = i * (i-1)! * a
%    = (i-1)! * (i*a)
% We have: i' = i-1 and a' = i*a
declare
fun {Fact2 I A}
   if I==0 then A
   else {Fact I-1 I*A} end
end
   #+end_src

* Type: 型
** Algebraic data type: 代数データ型
   関数型パラダイムで利用される.
   - [[http://ja.wikipedia.org/wiki/%E4%BB%A3%E6%95%B0%E7%9A%84%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B][代数的データ型 - Wikipedia]]

   それぞれの代数的データ型の値には,以下をもっている.
   - 1 個以上のコンストラクタ
   - 各コンストラクタには 0 個以上の引数

   2 引数で与えられた他のデータ型の値を, コンストラクタで包んだようなもの.
   - [[http://webcache.googleusercontent.com/search?q=cache:ZD5pznr5pjMJ:http://d.hatena.ne.jp/Lost_dog/20130616/1371416584%2B%E4%BB%A3%E6%95%B0%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B&hl=ja&&ct=clnk][Java で代数的データ型 - いじわるだねっ]]

*** Visual Basic
    Variant 型. なんでも入れることが出来る型だが, 
    メモリ使用量が多いので乱用はさける.
    - [[http://e-words.jp/w/VariantE59E8B.html][Variant 型とは 〔 バリアント型 〕 - 意味/ 解説/ 説明/ 定義 : IT 用語辞典]]

*** Haskell
    Haskell では, 以下を合わせて代数データ型と呼ぶ
    - 列挙型
      他の言語における enum
    - 直積型
    - 直和型
    
    参考:
    - [[http://qiita.com/7shi/items/1ce76bde464b4a55c143][Haskell 代数的データ型 超入門 - Qiita]]

** Enum: 列挙型
   プログラマが選んだ各々の識別子をそのまま有限集合として持つ抽象データ型.
   - [[http://ja.wikipedia.org/wiki/%E5%88%97%E6%8C%99%E5%9E%8B][列挙型 - Wikipedia]]

   番号を持たないカテゴリ変数. 一意の文字.
   
   実行時には, 番号が振られることが覆いが, 
   言語によっては番号はプログラマに見えないこともある.

* Bookmarks
  - [[https://docs.google.com/viewer?url=http://www.mew.org/~kazu/material/2010-func.pdf][Haskell 脳と Emacs Lisp 脳]]
  - [[http://postd.cc/who-teaches-functional-programming/][【翻訳】 US トップ大学でも関数型プログラミングが余り教えられていない現実 | POSTD]]  

  #+BEGIN_QUOTE
  関数型言語でプログラミングすることで, 学生は, データが帰納的に定義出来
  ることや, たくさんの興味深いアプリケーションが基本的にデータ型のパター
  ンマッチを使っていることや, コードは本質的にデータとは異なることや, 副
  作用を最小限に抑えることで連結が楽になることなど, 重要な見識を広げます.
  これらは例えあなたが Java や C++ でプログラミングするつもりであったとして
  も有用な見識なのです
  #+END_QUOTE

  - [[http://www.sampou.org/haskell/article/whyfp.html][なぜ関数プログラミングは重要か]]
