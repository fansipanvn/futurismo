#+OPTIONS: toc:nil
* Archtecture Patterns
  アーキテクチャパターン.

* POSA-1
会社の図書館にあった.

  http://www.amazon.co.jp/exec/obidos/ASIN/4764902834/asakichy-22/

** 混沌から構造へ
   複雑になりがちなソフトウェアの構造を整理して「分割して統治」するた
   めのパターン.

*** Layers
    アプリケーションを複数の"層"に分け, それらを独立したモジュールとし
    て開発・保守する. 各層はインタフェースを定義しモジュール化されたソ
    フトウェアであり, テクノロジーの進歩や要求の変化に合わせて各層を個
    別に置換できる.

    - [[http://ja.wikipedia.org/wiki/%E5%A4%9A%E5%B1%A4%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3][多層アーキテクチャ - Wikipedia]]

    分割が必要な大規模なシステムが前提. 小規模システムではいらない.

    - [[http://www.hakkaku.net/articles/20080630-227][八角研究所 : POSA 本でアーキテクチャパターンを勉強しよう Layers]]

    失敗談) Windows の Desktop Application を MVC でつくってやたらと時間が
    かかってしまった.

**** 特徴
     - 隣接しないレイヤへのアクセスを禁止
     - 片方向のアクセスを許可.

**** メリット
     1. 変更が局所化されるため保守性が向上する,
     2. 抽象度の低い下位レイヤは, さまざまなシステムで再利用できる可能性がある
     3. レイヤ間のやり取りが標準化されている場合, レイヤを交換することが容易になる

*** Pipes and Filters
*** lackboard
** 分散システム
   分散システムを開発する上で有効なパターン.

*** Broker
** 対話型システム
   人とコンピュータの対話 (クライアントとシステムの対話) を提供するシ
   ステムで有効なパターン

*** Model-View-Controller
    - [[http://kray.jp/blog/think_about_mvc/#][MVC について考える | KRAY Inc]]

*** Presentation-Abstraction-Control
** 適合型システム
   環境の変化や機能要求の変化による中核機能への影響を抑えるために有効
   なパターン.

*** Microkernel
*** Reflection
** Links
   - [[http://d.hatena.ne.jp/asakichy/20090602/1243900715][POSA のアーキテクチャパターン - Strategic Choice]]
     
   ここにある図がよい.
   - [[http://thinkit.co.jp/article/940/1][第 2 回 アーキテクチャーパターンとは何か | Think IT]]

* POSA-2  
  Schmidt 先生, 渾身の著作!

  なぞの PDF 群.
  - [[http://www.dre.vanderbilt.edu/~schmidt/PDF/][Index of /~schmidt/PDF]]
  
  とても参考になるリンク. POSA2.
  [[http://www.dre.vanderbilt.edu/~schmidt/POSA/POSA2/][Pattern-Oriented Software Architecture: Patterns for Concurrent and Networked Objects]]

  平行性に関するパターン. Wikipedia よりもってきた.

** Active Object (Actor) 
   メソッドの呼び出しとメソッドの実際の実行を分離することで並行性を導入する.
   各オブジェクトは利用者からの要求を管理するためのメッセージキューとスケジューラを持つ.
   
** Balking 
   前提条件が満たされていない場合は, (その時点での) 処理の実行をあきらめる.

** Double-checked locking 
   ロックの取得におけるオーバヘッドを削減するための技法.
   まずをスレッドセーフでない方法で「ロックヒント」を調べて, それが成功したら実際のロックを試みる.

** Future 
   「処理が完了しているかどうか分からない処理結果」を表すオブジェクトを作成することで同期を実現する.
   処理が完了していないうちに結果を取得しようとした場合は処理が完了するまでロックされる.

** Guarded suspension
   前提条件が満たされるまで待機するための機構.

** Lock 
   リソースに対して 1 つのスレッドが「ロック」をかけて,
   そのあいだ他のスレッドがそのリソースにアクセスしたり変更を加えたりできないようにする.

   - [[http://www.castle-cadenza.demon.co.uk/lock.htm][Lock Design Pattern]]

** Monitor 
   排他的に実行しなければならないメソッド群を持つオブジェクトを
   スレッドセーフに利用できるようにするための機構.
   Java はこれを言語レベルでサポートしている.

   - [[http://docs.oracle.com/javase/jp/6/api/javax/management/monitor/package-summary.html][javax.management.monitor (Java Platform SE 6)]]
   - [[http://en.wikipedia.org/wiki/Monitor_(synchronization)][Monitor (synchronization) - Wikipedia, the free encyclopedia]]

** Producer-consumer
   「生産者」 (producer) スレッド群がデータを生成して「通信路」に追加し,
   「消費者」 (consumer) スレッド群がそのデータを「通信路」から取り出して処理するという構造.

   必要な同期はすべて「通信路」によって行なわれるため,
   生産者と消費者のルーチンは同期を意識せずに実装できる.
   この通信路は同期キューなどで実現される (一部の言語はこれを標準ライブラリで提供している).

   - [[http://omiya6048.hatenablog.com/entry/2013/05/29/145253][Java で Producer-Consumer パターンを実践! - omiya6048's blog]]
   - [[http://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem][Producer – consumer problem - Wikipedia, the free encyclopedia]]

** Reactor (Evented)
   イベント駆動のためのパターン.

#+begin_src language
The reactor design pattern is an event handling pattern 
for handling service requests delivered concurrently 
to a service handler by one or more inputs.
#+end_src

   - [[http://en.wikipedia.org/wiki/Reactor_pattern][Reactor pattern - Wikipedia, the free encyclopedia]]

   Networking で利用される Reactor は, select を使った狭義の Reactor Pattern.
*** 特徴
    - イベント (入力データ) を,
      処理や状態を表すハンドラ (メソッド or サブクラス) に
      ディスパッチ (結びつける) する.
    - ハンドラごとに責務を分割できるので OOP 向き.

   EventMachine は Reactor パターンの高性能な実装さ.
   - [[http://keijinsonyaban.blogspot.jp/2010/12/eventmachine.html][見えないチカラ: 【翻訳】 EventMachine 入門]]

   Android は状態ごとにハンドラが呼び出される.
   - onCreate ()
   - onResume ()
   - onDestory ()

   Spring Framework では, GET や POST の HTTP request は, 
   それぞれ対応するメソッドにコールバックされる.

*** Structure
    - Resources: 入力データ
    - Synchronous Event Demultiplexer:入力データを拾うためのイベントループ.
                  シングルスレッドで loop していることが特徴 (Synchronous).
    - Dispatcher: ハンドラを管理する. Demultiplexer から通知を受けたら,
                  Resource を Handler に Dispatch する (select など)
    - Handler: Resource に関連付けられた処理.

** Readers-writer lock
   書き込みは排他アクセスが必要だが読み込みは
   並行に行えるようにしたい場合のためのロック機構.
   
   排他制御が必要な共有リソースのために導入する.
   
** Scheduler 
   シングルスレッドで実行される処理 (例えばファイルへの書き込み) の実行を各スレッドに許可するタイミングを明確に制御する.

** Thread pool
   多数のスレッドを作成してそれらに多数のタスクを処理させる.
   典型的な状況ではスレッド数よりもかなり多くのタスクが存在し,
   各スレッドは, あるタスクの処理が終わると次の処理待ちタスクの実行に取りかかる.
   一般に, Producer-consumer パターンを使って実現される.

** Thread-specific storage 
   静的変数・グローバル変数のように扱えるが
   スレッドごとに異なる内容を格納できるメモリ領域を提供する.

** Two-phase termination 
   スレッドを安全に終了させる方法.
   スレッドは, 終了要求を表すフラグを定期的に確認して, それがセットされたら終了処理を行う.

* POSA-3
* POSA-4
* POSA-5
* Network Architecture Patterns
  Working with TCP Sockets から.

** Serial
   - Structure is simple.
   - Resource usage is simple.
   - No concurrency.

** Process per connection
** Thread per connection
** Preforking
** Thread Pool
** Evented (Reactor)
*** 特徴
    - すべての処理をシングルスレッドで実施する.
    - マルチスレッドを利用しなくても, 非同期処理がかける.
    - スレッドやプロセス数の制限なしに, クライアントからの要求に答えることができる.
      
*** 実装方法
    - ソケットを select で監視する.
      読み取り可能, 書き込み可能なソケットのみに対して処理を実施する.
    - 遅い回線があるときに, その回線に引きずられて Reactor が他の処理をできない.
      すべての処理が Blocking される.
      そんなときは, non-blocking write を利用する.

*** sample
**** synchronized
#+begin_src ruby
hosts.each do |host|
  sock = TCPSocket.new (host, 80)
  sock.write (request)
  sock.read
  sock.close
end
#+end_src

**** threads
#+begin_src ruby
threads = hosts.map do |host|
  Thread.new (host) do |h|
    sock = TCPSocket.new (h, 80)
    sock.write (request)
    sock.read
    sock.close
  end
end
threads.each{|t| t.join}
#+end_src

**** reactor
#+begin_src ruby
write_socks = hosts.map do |host|
  TCPSocket.new (host, 80)
end
read_socks = []

# handler
write_proc = lambda{|sock|
  sock.write (request)
}

# handler
read_proc = lambda{|sock|
  sock.read
  sock.close
}

# Reactor
until (write_socks + read_socks).empty?

  # Demultiplexer
  r_socks, w_socks, e_socks = IO.select (read_socks, write_socks)

  # Dispatcher
  if ws = w_socks.first
    write_proc.call (ws)
    read_socks << ws
    write_socks.delete (ws)
  end

  # Dispatcher
  if rs = r_socks.first
    read_proc.call (rs)
    read_socks.delete (rs)
  end
end
#+end_src

*** Links
   - [[http://gihyo.jp/dev/serial/01/ruby/0030?page=1][第 29 回  Reactor で非同期処理をやってみよう (1):Ruby Freaks Lounge|gihyo.jp … 技術評論社]]
   - [[http://gihyo.jp/dev/serial/01/ruby/0032][第 32 回  Reactor で非同期処理をやってみよう (2):Ruby Freaks Lounge|gihyo.jp … 技術評論社]]

** Hybrids

* Doug 氏 Original Patterns
  なぞの PDF 群からのパターン集.
  - [[http://www.dre.vanderbilt.edu/~schmidt/PDF/][Index of /~schmidt/PDF]]

** Wrapper Facade
   ソケットなどの OS に依存するような 
   native methods に対してラッパーライブラリを作成すること.

#+begin_src language
encapsulate low-level functions and data
structures with object-oriented (OO) class interfaces.
#+end_src

   以下のメリットがある.

   - Non-OOP 言語が OOP で利用できたり (Type-safe I/F)
   - OS 依存がなくなったり, (Portable)
   - コンパイル時にエラーをチェックする機能を作り込んだりして,
     API error-prone (誤りがちな) を防ぐ.

   Facade や Bridge と異なり, 
   薄く, Light weight な実装でオーバヘッドがないことが特徴.

   coursera の posa 講義で出てきたパターン. Doug 氏 の論文.
   - http://www.cs.wustl.edu/~schmidt/PDF/wrapper-facade.pdf

   言語レベルでサポートされていることが多い?
   Ruby の Socket Library がよい例.
   bind や listen を TCPServer メソッドで隠している.

#+begin_src ruby
server = TCPServer.new (4481)

# => 
server = Socket.new (:INET, :STREAM)
addr = Socket.pack_sockaddr_in (4481, "0.0.0.0")
server.bind (addr)
server.listen (5)
#+end_src

** Acceptor-Connector
   Reactor Pattern において, Handler と Reactor の仲介を行う.

   Handler に Dispatch する前に, 一連の手続きが必要な場合には,

   - Acceptor が Handler に対して手続きを実施してから (Accept)
   - Reactor から Handler への Dispatch をさせる (Connect)
  
