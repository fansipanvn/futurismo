#+OPTIONS: toc:t num:nil author:nil creator:nil LaTeX:t
* Pattern
** Archtecture Pattern
** Design Pattern
[[http://ja.wikipedia.org/wiki/%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3_(%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2)][デザインパターン (ソフトウェア) - Wikipedia]]
** idiom

** Book
[[http://www.amazon.co.jp/%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%80%81Wiki%E3%80%81XP-~%E6%99%82%E3%82%92%E8%B6%85%E3%81%88%E3%81%9F%E5%89%B5%E9%80%A0%E3%81%AE%E5%8E%9F%E5%89%87-WEB-PRESS-plus%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA/dp/4774138975][Amazon.co.jp： パターン、Wiki、XP ~時を超えた創造の原則 (WEB+DB PRESS plusシリーズ): 江渡 浩一郎: 本]]

* Gof
** 生成に関するパターン
*** Factory Method 
    オブジェクトの生成を行う時のインタフェースを規定して、 
    インスタンス化するクラスを決定するのはサブクラスに任せる。

    - [[http://ja.wikipedia.org/wiki/Factory_Method_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3][Factory Method パターン - Wikipedia]]

**** C言語での応用
     C言語でAbstruct Data Typeな設計をつかうときの常套手段。

#+begin_src c
int createInstance(void) {
  return calloc(4);
}

int destroyInstance(int ptr) {
  free(ptr);
  return NULL;
}

int main(void) {
  int *instance = createInstance();
  instance = destoryInstance(instance);
  return 0;
}
#+end_src


*** Abstract Factory 
関連するオブジェクト群を、その具象クラスを明確にせずに生成するための インタフェースを提供する。
*** Builder 
オブジェクトの生成手順が複雑な場合に、その生成過程をカプセル化する。
*** Prototype
生成するオブジェクトの原型をコピーして新しいオブジェクトを生成する。
*** Singleton 
システム内で生成可能なインスタンス数をひとつだけに制限する。
** 構造に関するパターン
*** Adapter 
インタフェースを変換することにより、インタフェースに互換性がない クラス同士を接続する。
*** Bridge 
クライアントがアクセスするクラス(インタフェース)と実装クラスを分離して、 それぞれを独立に変更できるようにする。
*** Composite 
部分－全体階層を表現するために、クラスの木構造に組み立てる。 同一のクラスから派生したサブクラスを木構造のノードとし、 クライアントは木構造の任意の部分を同一のインタフェースで扱える。
*** Decorator 
サブクラス化ではなく委譲により、クラスに新しい機能を追加する。
*** Facade 
複数のクラス群からなるサブシステムにアクセスするためのインタフェースを提供する。
*** Flyweight 
一度生成したインスタンスはプーリングしておき、必要なときに取り出して使う。
*** Proxy 
オブジェクトへのアクセスをフックするための代理オブジェクトを提供する。
** 振る舞いに関するパターン
*** Command 
要求をオブジェクトとしてカプセル化し、要求の発生と実際の処理を分離する。
*** Chain of Responsibility 
クライアントからの要求を複数のオブジェクトでたらいまわしにする。
*** Interpreter 
文字列からなる構文を構文解析(Interprete)し、 構文を表現したオブジェクト構造ともとの文字列を関連付ける。
*** Iterator 
オブジェクトの集合があるとき、その集合の内部構造はカプセル化したままで、 要素に対して順にアクセスする方法を提供する。
*** Mediator 
複数のオブジェクトを相互作用させる場合に、お互いのオブジェクト同士が直接参照する ことをなくすため、相互作用そのものをオブジェクトとして定義する。
*** Memento 
オブジェクトの状態を保存しておき、元に戻せるようにしておく。
*** Observer 
あるオブジェクトに依存した複数のオブジェクトがある場合に、 被依存オブジェクトの状態変化を、依存オブジェクトに通知する。
*** State 
    状態に応じてオブジェクトの振る舞いを変更したいときに、 
    振る舞いを別オブジェクトにカプセル化する。

*** Strategy 
    アルゴリズムをカプセル化して、アルゴリズムを交換可能にする。 
    ひとつの入力データに対して、アルゴリズム毎に異なる結果を出力する。

    - [[http://ja.wikipedia.org/wiki/Strategy_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3][Strategy パターン - Wikipedia]]

    アプリケーションで使用されるアルゴリズムを動的に切り替える必要がある際に有用.

    - Android
    - Windows
    - Linux

**** 名前のつけかた
     xxxStrategy

*** Template Method 
    アルゴリズムを複数のステップに分解し、
    それぞれのステップを抽象メソッドにする。 
    各ステップでのメソッドの実装はサブクラスで定義する。

    システムのフレームワークを構築するための手段としてよく活用される.

    [[Factory Method]] パターンは、内部に [[Template Method]] パターンを包含することが多い

    - [[http://ja.wikipedia.org/wiki/Template_Method_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3][Template Method パターン - Wikipedia]]

#+begin_src ruby
class A
  def execute()
    raise "to be implemented"
  end
end

class B < A
  def execute()
  end
end

class C < A
  def execute()
  end
end
#+end_src

*** Visitor 
複数のオブジェクトからなるオブジェクト構造があるときに、 それぞれのオブジェクト要素に処理を追加またはオブジェクト要素の処理を変更するため、 Visitorクラスを用意する。

** Links
- http://homepage3.nifty.com/satoshis/oo/patterns.html

* POSA
** 混沌から構造へ
*** Layers
*** Pipes and Filters
*** lackboard
** 分散システム
*** Broker
** 対話型システム
*** Model-View-Controller
*** Presentation-Abstraction-Control
** 適合型システム
*** Microkernel
*** Reflection

** Links
- [[http://d.hatena.ne.jp/asakichy/20090602/1243900715][POSAのアーキテクチャパターン - Strategic Choice]]

ここにある図がよい。
- [[http://thinkit.co.jp/article/940/1][第2回 アーキテクチャーパターンとは何か | Think IT]]

なぞのPDF群。
- [[http://www.dre.vanderbilt.edu/~schmidt/PDF/][Index of /~schmidt/PDF]]

* Multi-Thread Programming
平行性に関するパターン。

** Active Object (Actor) 
メソッドの呼び出しとメソッドの実際の実行を分離することで並行性を導入する。
各オブジェクトは利用者からの要求を管理するためのメッセージキューとスケジューラを持つ。

** Balking 
前提条件が満たされていない場合は、(その時点での)処理の実行をあきらめる。

** Double-checked locking 
ロックの取得におけるオーバヘッドを削減するための技法。
まずをスレッドセーフでない方法で「ロックヒント」を調べて、それが成功したら実際のロックを試みる。

** Future 
「処理が完了しているかどうか分からない処理結果」を表すオブジェクトを作成することで同期を実現する。
処理が完了していないうちに結果を取得しようとした場合は処理が完了するまでロックされる。

** Guarded suspension
   前提条件が満たされるまで待機するための機構。

** Lock 
リソースに対して１つのスレッドが「ロック」をかけて、
そのあいだ他のスレッドがそのリソースにアクセスしたり変更を加えたりできないようにする。

- [[http://www.castle-cadenza.demon.co.uk/lock.htm][Lock Design Pattern]]

** Monitor 
排他的に実行しなければならないメソッド群を持つオブジェクトをスレッドセーフに利用できるようにするための機構。
Javaはこれを言語レベルでサポートしている。

** Producer-consumer
 「生産者」 (producer) スレッド群がデータを生成して「通信路」に追加し、
「消費者」 (consumer) スレッド群がそのデータを「通信路」から取り出して処理するという構造。
必要な同期はすべて「通信路」によって行なわれるため、
生産者と消費者のルーチンは同期を意識せずに実装できる。
この通信路は同期キューなどで実現される（一部の言語はこれを標準ライブラリで提供している）。

- [[http://omiya6048.hatenablog.com/entry/2013/05/29/145253][JavaでProducer-Consumerパターンを実践！ - omiya6048's blog]]
- [[http://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem][Producer–consumer problem - Wikipedia, the free encyclopedia]]

** Reactor
 同期的に扱わなければならないリソース群に対する非同期的インタフェースを提供する。

** Readers-writer lock
   書き込みは排他アクセスが必要だが読み込みは
   並行に行えるようにしたい場合のためのロック機構。

   排他制御が必要な共有リソースのために導入する。

** Scheduler 
シングルスレッドで実行される処理（例えばファイルへの書き込み）の実行を各スレッドに許可するタイミングを明確に制御する。

** Thread pool
多数のスレッドを作成してそれらに多数のタスクを処理させる。
典型的な状況ではスレッド数よりもかなり多くのタスクが存在し、
各スレッドは、あるタスクの処理が終わると次の処理待ちタスクの実行に取りかかる。
一般に、Producer-consumerパターンを使って実現される。

** Thread-specific storage 
   静的変数・グローバル変数のように扱えるがスレッドごとに異なる内容を格納できるメモリ領域を提供する。

** Two-phase termination 
   スレッドを安全に終了させる方法。
   スレッドは、終了要求を表すフラグを定期的に確認して、それがセットされたら終了処理を行う。

** Ping-Pong Problem
* Functional Programming

- [[http://patternsinfp.wordpress.com/][Patterns in Functional Programming | Exploiting the relationship between data structure and program structure]]

* Embedded System Programming
** Finate State Machine
有限オートマン。状態遷移のための制御方法。

- [[http://ja.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E3%82%AA%E3%83%BC%E3%83%88%E3%83%9E%E3%83%88%E3%83%B3][有限オートマトン - Wikipedia]]

以下の5つの構成要素からなる。

- Inputs
- Outputs
- States
- State Transition Graph(STG)
 - Tree
 - Matrix
- Output Determination

*** Moore Machine
ムーアマシン。
出力が（入力によらず）現在の状態によってのみ決定される有限オートマトン。

#+begin_src language
NextState = f(Input, CurrentState)
Output = g(CurrentState)
#+end_src

*** Mealy Machine
ミーリマシン。
出力が現在状態と入力によって決定される有限オートマトン。

#+begin_src language
Output = h(Input, CurrentState)
#+end_src

*** 実装方法
#+begin_src c

#define N = 2

typedef enum { yes, no} state;
struct FSM {
  unsigned char out;     /* レシジスタへの出力 */
  unsigned char next[N]  /* 次の状態グラフ。ここではMatrix */
};

#+end_src



* Links
  [[http://www.hyuki.com/dp/dpinfo.html][デザインパターン紹介]]
  結城浩さんの並列・平行プログラミングのパターン紹介

